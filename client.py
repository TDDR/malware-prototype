#!/usr/bin/env python3

#==============================================================================
 #   Assignment:  Milestone 3
 #
 #       Author:  Tim Robetrs 
 #     Language:  Python 3
 #       
 #   To Compile:  Daemon must be running
 #
 #        Class:  DPI 912 Sockets and Security
 #    Professor:  Harvey Kaduri
 #     Due Date:  14-June-2020
 #    Submitted:  14-June-2020
 #
 #-----------------------------------------------------------------------------
 #
 #  Description:  Upgrade the client from m1 to send multiple requests to the daemon.
 #    
 #        Input:  On startup, the user can provide how many clients and how many
 #                connections those clients make via CIL. Defualts are given though
 #                so not necessary.
 #
 #       Output:  The ticket will display on STDOUT and be written to a file.
 #
 #    Algorithm:  The client now utilizes fork() to make multiple requests to the daemon.
 #                The client now auto generates each request to the daemon. In response the 
 #                daemon will return the generated lottery ticket information.
 #                
 #                * Added a zombie collector after reciveing your feedback from m2.
 #
 #   Required Features Not Included: n/a
 #
 #   Known Bugs: Some asynchronous issues pop up in the first couple of requests 
 #               that get sorted out after all the clients are connected. 
 #
 #   Classification: A
 #
#==============================================================================
import argparse
import random
import signal
import errno
import json
import os

from libraries.socket import ClientSocket
from libraries.signalHandler import SignalHandler

def printTicket(ticket):

    with open("LotteryTickets.json", "a") as writeToFile:
        json.dump(ticket, writeToFile)
        
    print("Id:", "".join(ticket["id"]))
    print(ticket["typeOfTicket"], "\n")

    if ticket["typeOfTicket"] == "Lotto Max":
        for i in ticket["numbers"]:
            print(*i , sep = "\n" )
            print("\n")         
    else:
        print(*ticket["numbers"], sep = "\n\n" )
        print("\n")

def sendRequest(clientSocket):
    
    idPool = [chr(i) for i in range(ord("0"), ord("z") + 1)]

    #typeOfTicket = input("Please choose what type of ticket\n1 -> Lotto Max\n2 -> Lotto 6/49\n 3 -> Daily Grand")
    typeOfTicket = 2
    identifier = random.sample(idPool, 6)

    dataToSend = dict(typeOfTicket = typeOfTicket, numberOfTickets = 1, identifier = identifier)
    ClientSocket.sendData(dataToSend)

def main(maxConnections, maxClients):

    ip = "localhost"
    port = 5555
    sockets = []

    for clientNumber in range(maxClients):
        try:
            pid = os.fork()       
        except OSError:
            sys.stderr.write("Could not fork() a child")
            continue
    
        if pid == 0:
            for connectionNumber in range(maxConnections):
                
                client = ClientSocket(ip, port)

                sendRequest(client)
                sockets.append(client)

                dataRecived = client.receiveData()

                print(f"Client# {clientNumber + 1 } : Connection# {connectionNumber + 1}")
                printTicket(dataRecived)
        
            os._exit(0)

    signal.signal(signal.SIGCHLD, SignalHandler.childSignalHandler)
        
if __name__ == '__main__': 
    
    argParser = argparse.ArgumentParser()

    argParser.add_argument("-c", "--maxConections", type=int, 
                            nargs = "?", default = 3, const = 3,
                            help="Maximum amount of connections (defualt 25).", dest = "maxConnections")

    argParser.add_argument("-n", "--maxClients", type=int,
                            nargs = "?", default = 3, const = 3,
                            help="Maximum amount of clients (default 1).", dest = "maxClients")

    switches = argParser.parse_args()

    main(switches.maxConnections, switches.maxClients)