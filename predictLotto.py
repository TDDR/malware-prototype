#!/usr/bin/env python3

import logzero
import signal
import atexit
import errno
import json
import sys
import os
from socket import *
from logzero import logger

from libraries.Ticket import *


def handleClient(connectionSocket):

    ticket = []

    dataRecived = eval(connectionSocket.recv(1000).decode())

    typeOfTicket = dataRecived["typeOfTicket"]
    numberOfTickets = dataRecived["numberOfTickets"]
    identifier = dataRecived["identifier"]

    while numberOfTickets > 0:

        if typeOfTicket == 1:
            ticket.append(LottoMax())
            ticketType = "Lotto Max"

        elif typeOfTicket == 2:
            ticket.append(Lotto649())
            ticketType = "Lotto 6/49"

        elif typeOfTicket == 3:
            ticket.append(DailyGrand())
            ticketType = "Daily Grand"

        numberOfTickets -= 1

    dataToSend = dict(typeOfTicket=ticketType, numbers=[], id=identifier)
    for i in ticket:
        dataToSend["numbers"].append(i.generateNumbers())

    connectionSocket.sendall(str(dataToSend).encode())

    return dataToSend


def zombieSlayer(signalNumber, frame):

    while True:
        try:
            pid, status = os.waitpid(-1, os.WNOHANG)

        except OSError:
            return

    if pid == 0:
        return


def terminator(signalNumber, frame):
    raise SystemExit(1)


def daemonize(
        pidfile,
        *,
        stdin="/dev/null",
        stdout="/dev/null",
        stderr="/dev/null"):

    if os.path.exists(pidfile):
        raise RuntimeError("Already  running")

    try:
        if os.fork() > 0:
            raise SystemExit(0)

    except OSError as e:
        raise RuntimeError("fork  #1 failed.")

    os.chdir("/")
    os.umask(0)
    os.setsid()

    try:
        if os.fork() > 0:
            raise SystemExit(0)

    except OSError as e:
        raise RuntimeError("fork  #2 failed.")

    sys.stdout.flush()
    sys.stderr.flush()

    with open(stdin, "rb", 0) as f:
        os.dup2(f.fileno(), sys.stdin.fileno())

    with open(stdout, "ab", 0) as f:
        os.dup2(f.fileno(), sys.stdout.fileno())

    with open(stderr, "ab", 0) as f:
        os.dup2(f.fileno(), sys.stderr.fileno())

    with open(pidfile, "w") as f:
        print(os.getpid(), file=f)

    atexit.register(lambda: os.remove(pidfile))

    signal.signal(signal.SIGTERM, terminator)


def main():

    ip = "localhost"
    port = 8080
    numberOfClients = 1000

    serverSocket = socket(AF_INET6, SOCK_STREAM)
    serverSocket.bind((ip, port))
    serverSocket.setsockopt(SOL_SOCKET, SO_REUSEPORT, 1)
    serverSocket.listen(numberOfClients)

    signal.signal(signal.SIGCHLD, zombieSlayer)

    while True:

        connectionSocket, address = serverSocket.accept()

        try:
            pid = os.fork()

        except OSError:
            sys.stderr.write("Could not fork in main")
            logger.error("Could not fork in main")
            continue

        if pid == 0:
            serverSocket.close()
            dataSent = handleClient(connectionSocket)

            requestID = "".join(dataSent["id"])
            logger.info(f"CHILD PID: {os.getpid()} request id -> {requestID}")

            connectionSocket.close()
            os._exit(0)
        else:
            logger.info(f"PARENT PID: {os.getpid()}")
            connectionSocket.close()


if __name__ == "__main__":

    PIDFILE = "/tmp/daemon.pid"
    logzero.logfile(
        "/tmp/rotating-logfile.log",
        maxBytes=1e6,
        backupCount=3,
        disableStderrLogger=True)

    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} [start|stop]", file=sys.stderr)
        raise SystemExit(1)

    if sys.argv[1] == "start":
        try:
            daemonize(
                PIDFILE,
                stdout="/tmp/daemon.log",
                stderr="/tmp/dameon.log")

        except RuntimeError as e:
            print(e, file=sys.stderr)
            raise SystemExit(1)

        logger.info(f"Started {os.getpid()}")
        main()

    elif sys.argv[1] == "stop":
        if os.path.exists(PIDFILE):
            with open(PIDFILE) as f:
                os.kill(int(f.read()), signal.SIGTERM)
        else:
            print("Not  running", file=sys.stderr)
            raise SystemExit(1)
    else:
        print(f"Unknown  command  {sys.argv[1] !r}", file=sys.stderr)
        raise SystemExit(1)
